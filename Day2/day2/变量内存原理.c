#include<stdio.h>

/*
	通过内存修改变量的值在打印出来
	变量只是引用一个内存地址,如果内存地址对应的值发生了变化,那么变量的值也会被改变.
*/
void test1() {
	int a = 10;

	printf("%p\n", &a);

	printf("%d\n", a);
}

/*
	变量的内存机制
*/
void test2() {
	int a = 2;
	int b = 3;
	int c;	//c语言中声明一个变量必须要赋值,C语言不会自动对其进行初始化,如果引用的那个内存地址之前有值,那么就会成为它的值,这个值也许会导致后面出问题(比如程序崩溃),变量使用前必须要初始化.

	printf("%p,%p,%p\n",&a,&b,&c);

	c = a + b;

	printf("\n");
}

/*
	变量赋值的原理:使用汇编模拟赋值给变量的过程
	int a = 10的过程分析:
		1.首先在编译器的只读代码区的常量符号表里存放了一个10(代码中每声明并赋值一个就往常量符号表里添加一个,等待寄存器提取)
		2.由cpu中的寄存器来提取并产生这个10,然后转成二进制,先行存放于寄存器中,然后通过mov指定赋值给声明的变量对应的内存地址.
		3.10不是在内存里面产生的,所以int a = 10并不是直接将10赋值给内存地址.
*/
void test3() {
	int a = 5;
	int b = 0;
	printf("%p,%p\n", &a, &b);
	//通过汇编给内存地址赋值
	_asm {
		//mov b,a 内存不允许直接给内存赋值,如果需要把一个变量的值赋值给另一块内存,必须经由寄存器来完成.
		mov eax, a;
		mov b, eax;
	}
	//通过汇编实现变量加的操作
	_asm {
		mov eax, a;
		add eax, 5;
		mov a, eax;
	}
	printf("%p,%p\n", &a, &b);
}

/*
	表达式的计算过程
*/
void test4() {
	int a = 3;
	int b = 4;
	int c = 0;
	printf("%p,%p,%p\n",&a,&b,&c);

	/*
		a + 1 = b语句错误的原因
		原因:(a+1)的表达式的计算是由cpu中的寄存器完成之后再赋值给内存的,内存不允许直接给内存赋值,必须经由寄存器,而赋值只能针对存在于内存中可以使用的内存地址,而该表达式它没有地址,所以a + 1 = b是错误的语句.
		结论:只能给变量赋值,且该变量必须存在于内存中.
	*/
	//a + 1 = b; 
	c = a + 1;
	b = b + 2;
}
int main() {
	//test1();
	//test2();
	test3();
	//test4();

	getchar();
	return 0;
}